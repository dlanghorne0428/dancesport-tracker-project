import json
from operator import itemgetter

from .models import Heat
from rankings.models import Couple, Dancer

age_div_prefix_list = ("L-", "G-", "AC-", "Pro ", "AC-", "Professional", "AM/AM", "Amateur", "Youth", "MF-", "M/F")

class Heatlist():
    '''This class is a base class to store heat list information for a competition.'''

    def __init__(self):
        # store the name of the comp,
        self.comp_name = "--Click Open to load a Heat Sheet File--"
        self.unmatched_heats = 0
        self.dancers = list()               # store a list of the individual dancers competing
        #self.couples = list()               # store a list of the couples competing
        #self.heats = list()
        #self.heat_entries = list()


    def split_name(self, name):
        name_fields = name.split(",")
        if len(name_fields) == 2:
            # look for middle name
            first_fields = name_fields[1][1:].split()
            if len(first_fields) == 1:
                # no middle name
                return (name_fields[0], first_fields[0], "")
            else:
                #print("Middle Name", name_fields[0], first_fields[0], first_fields[1])
                # TODO: what if two middle names?
                return (name_fields[0], first_fields[0], first_fields[1])


    ############### DANCER / COUPLE ROUTINES  ###########################################
    # the following methods deal with dancers and couples in the competition
    #####################################################################################
    def dancer_name_list(self):
        '''This method returns a list of dancer names in this competition.'''
        l = list()
        for d in self.dancers:
            l.append(d.name)
        return l

    def find_dancer(self, dancer_name):
        '''This method finds the dancer object from the list based on the name.'''
        for d in self.dancers:
            if d.name == dancer_name:
                return d
        else:
            return None


    def find_couple_exact_match(self, heatlist_dancer, heatlist_partner, couple_type):
        dancer_last, dancer_first, dancer_middle = self.split_name(heatlist_dancer.name)
        partner_last, partner_first, partner_middle = self.split_name(heatlist_partner.name)
        try:
            dancer = Dancer.objects.get(name_last = dancer_last, name_first = dancer_first, name_middle = dancer_middle)
        except:
            return (None, None)
        try:
            partner = Dancer.objects.get(name_last = partner_last, name_first = partner_first, name_middle = partner_middle)
        except:
            return (None, None)

        couples = Couple.objects.filter(dancer_1 = dancer, dancer_2 = partner, couple_type = couple_type)
        matches = couples.count()
        if matches > 1:
            print("Error: multiple matches for", heatlist_dancer.name, "and", heatlist_partner.name)
            print(matches)
            return (None, None)
        elif matches == 1:
            return (couples.first(), heatlist_dancer.code)
        else:
            couples = Couple.objects.filter(dancer_2 = dancer, dancer_1 = partner, couple_type = couple_type)
            matches = couples.count()
            if matches > 1:
                print("Error: multiple matches for", heatlist_dancer.name, "and", heatlist_partner.name)
                print(matches)
                return (None, None)
            elif matches == 1:
                return (couples.first(), heatlist_partner.code)
            else:
                return (None, None)


    # this module processes a ballroom competition heatlist file in HTML format generated by the CompMngr program.

    def find_last_name_matches(self, dancers, dancer_1_code, dancer_2_code):
        partial_matches = list()
        for d in dancers:
            couples = Couple.objects.filter(dancer_1 = d)
            for c in couples:
                partial_matches.append((c, dancer_1_code))
            couples = Couple.objects.filter(dancer_2 = d)
            for c in couples:
                partial_matches.append((c, dancer_2_code))
        return partial_matches


    def find_couple_partial_match(self, dancer, partner):
        dancer_last, dancer_first, dancer_middle = self.split_name(dancer.name)
        partner_last, partner_first, partner_middle = self.split_name(partner.name)
        partial_matching_couples = list()

        dancers = Dancer.objects.filter(name_last = dancer_last)
        partial_matches = self.find_last_name_matches(dancers, dancer.code, partner.code)
        for p in partial_matches:
            if p not in partial_matching_couples:
                partial_matching_couples.append(p)

        if partner_last != dancer_last:
            partners = Dancer.objects.filter(name_last = partner_last)
            partial_matches = self.find_last_name_matches(partners, partner.code, dancer.code)
            for p in partial_matches:
                if p not in partial_matching_couples:
                    partial_matching_couples.append(p)

        return partial_matching_couples


    def add_heat_to_database(self, heat, comp_ref):
        if heat.category == Heat.PRO_HEAT or heat.multi_dance():
            heats_in_database = Heat.objects.filter(comp=comp_ref, category=heat.category, heat_number=heat.heat_number, info=heat.info)
            if heats_in_database.count() > 0:
                h = heats_in_database.first()
                #print("Found matching heat")
            else:
                h = heat
                #print("Saving", h)
                h.save()   # save the heat into the database
            return h
        else: # not a heat that we care about
            return None
