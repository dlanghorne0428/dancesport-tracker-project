import json
from operator import itemgetter

from rankings.models import Couple, Dancer
from .models import Heat, HeatEntry, HeatlistDancer, UnmatchedHeatEntry


age_div_prefix_list = ("L-", "G-", "AC-", "Pro ", "AC-", "Professional", "AM/AM", "Amateur", "Youth", "MF-", "M/F")

class Heatlist():
    '''This class is a base class to store heat list information for a competition.'''

    def __init__(self):
        # store the name of the comp,
        self.comp_name = "--Click Open to load a Heat Sheet File--"
        self.unmatched_heats = 0
        self.dancers = list()               # store a list of the individual dancers competing


    def split_name(self, name):
        name_fields = name.split(",")
        if len(name_fields) == 2:
            # look for middle name
            first_fields = name_fields[1][1:].split()
            if len(first_fields) == 1:
                # no middle name
                return (name_fields[0], first_fields[0], "")
            else:
                #print("Middle Name", name_fields[0], first_fields[0], first_fields[1])
                # TODO: what if two middle names?
                return (name_fields[0], first_fields[0], first_fields[1])


    ############### DANCER / COUPLE ROUTINES  ###########################################
    # the following methods deal with dancers and couples in the competition
    #####################################################################################
    def dancer_name_list(self):
        '''This method returns a list of dancer names in this competition.'''
        l = list()
        for d in self.dancers:
            l.append(d.name)
        return l

    def find_dancer(self, dancer_name, format_needed = False):
        '''This method finds the dancer object from the list based on the name.'''
        for d in self.dancers:
            if format_needed:
                name_fields = dancer_name.split()
                for f in range(1, len(name_fields)):
                    name_scramble = d.format_name(dancer_name, simple=False, split_on=f)
                    if d.name == name_scramble:
                        return d
            else:
                if d.name == dancer_name:
                    return d
        else:
            return None


    def find_couple_exact_match(self, heatlist_dancer, heatlist_partner, couple_type):
        dancer_last, dancer_first, dancer_middle = self.split_name(heatlist_dancer.name)
        partner_last, partner_first, partner_middle = self.split_name(heatlist_partner.name)
        try:
            dancer = Dancer.objects.get(name_last = dancer_last, name_first = dancer_first, name_middle = dancer_middle)
        except:
            return (None, None)
        try:
            partner = Dancer.objects.get(name_last = partner_last, name_first = partner_first, name_middle = partner_middle)
        except:
            return (None, None)

        couples = Couple.objects.filter(dancer_1 = dancer, dancer_2 = partner, couple_type = couple_type)
        matches = couples.count()
        if matches > 1:
            print("Error: multiple matches for", heatlist_dancer.name, "and", heatlist_partner.name)
            print(matches)
            return (None, None)
        elif matches == 1:
            return (couples.first(), heatlist_dancer.code)
        else:
            couples = Couple.objects.filter(dancer_2 = dancer, dancer_1 = partner, couple_type = couple_type)
            matches = couples.count()
            if matches > 1:
                print("Error: multiple matches for", heatlist_dancer.name, "and", heatlist_partner.name)
                print(matches)
                return (None, None)
            elif matches == 1:
                return (couples.first(), heatlist_partner.code)
            else:
                return (None, None)


    # this module processes a ballroom competition heatlist file in HTML format generated by the CompMngr program.

    def find_last_name_matches(self, dancers, dancer_1_code, dancer_2_code):
        partial_matches = list()
        for d in dancers:
            couples = Couple.objects.filter(dancer_1 = d)
            for c in couples:
                partial_matches.append((c, dancer_1_code))
            couples = Couple.objects.filter(dancer_2 = d)
            for c in couples:
                partial_matches.append((c, dancer_2_code))
        return partial_matches


    def find_couple_partial_match(self, dancer, partner):
        dancer_last, dancer_first, dancer_middle = self.split_name(dancer.name)
        partner_last, partner_first, partner_middle = self.split_name(partner.name)
        partial_matching_couples = list()

        dancers = Dancer.objects.filter(name_last = dancer_last)
        partial_matches = self.find_last_name_matches(dancers, dancer.code, partner.code)
        for p in partial_matches:
            if p not in partial_matching_couples:
                partial_matching_couples.append(p)

        if partner_last != dancer_last:
            partners = Dancer.objects.filter(name_last = partner_last)
            partial_matches = self.find_last_name_matches(partners, partner.code, dancer.code)
            for p in partial_matches:
                if p not in partial_matching_couples:
                    partial_matching_couples.append(p)

        return partial_matching_couples


    def add_heat_to_database(self, heat, comp_ref):
        if heat.category == Heat.PRO_HEAT or heat.multi_dance():
            heats_in_database = Heat.objects.filter(comp=comp_ref, category=heat.category, heat_number=heat.heat_number, info=heat.info)
            if heats_in_database.count() > 0:
                h = heats_in_database.first()
                #print("Found matching heat")
            else:
                h = heat
                #print("Saving", h)
                h.save()   # save the heat into the database
            return h
        else: # not a heat that we care about
            return None


    def build_unmatched_heat_entry(self, heat_entry, heatlist_dancer, heatlist_partner, couple, code):
        # first save the dancer and partner, if necessary
        dancer_in_database = HeatlistDancer.objects.filter(name = heatlist_dancer.name)
        if dancer_in_database.count() == 0:
            #print("Saving", heatlist_dancer.name, "to database")
            heatlist_dancer.save()
            d = heatlist_dancer
        else:
            d = dancer_in_database.first()
        partner_in_database = HeatlistDancer.objects.filter(name = heatlist_partner.name)
        if partner_in_database.count() == 0:
            #print("Saving", heatlist_partner.name, "to database")
            heatlist_partner.save()
            p = heatlist_partner
        else:
            p = partner_in_database.first()
        mismatch = UnmatchedHeatEntry()
        mismatch.populate(heat_entry, d, p, couple, code)
        return mismatch


    def build_heat_entry(self, heat, dancer, partner, shirt_number):
        '''This method builds a HeatEntry object for the current dancer, partner, and shirt number.'''

        couple_type = heat.couple_type()
        couple, code = self.find_couple_exact_match(dancer, partner, couple_type)
        heat_entry_obj = HeatEntry()
        # populate and save matching heat entry
        if couple is not None:
            heat_entry_obj.populate(heat, couple, code, shirt_number)
            entries_in_database = HeatEntry.objects.filter(heat=heat, couple=couple, shirt_number=shirt_number)
            if entries_in_database.count() == 0:
                #print(heat_entry_obj.heat.category, heat_entry_obj.heat.heat_number, heat_entry_obj.couple, "Shirt #", heat_entry_obj.shirt_number)
                heat_entry_obj.save()
            # else:
            #     print("Heat Entry exists")
        else:
            # populate and save partially completed heat entry
            heat_entry_obj.populate(heat, shirt_number=shirt_number)
            #print("Mismatch:", heat_entry_obj.heat.category, heat_entry_obj.heat.heat_number)
            entries_in_database = HeatEntry.objects.filter(heat=heat, shirt_number=shirt_number)
            if entries_in_database.count() == 0:
                heat_entry_obj.save()
                he = heat_entry_obj
            else:
                he = entries_in_database.first()
                #print("Unmatched Heat Entry exists")

            # build list of possible matches for this heat entry and save them
            partial_matches = self.find_couple_partial_match(dancer, partner)
            for couple, code in partial_matches:
                mismatch = self.build_unmatched_heat_entry(he, dancer, partner, couple, code)
                #print(mismatch.dancer.name, mismatch.partner.name, mismatch.code, mismatch.couple)
                mismatches_in_database = UnmatchedHeatEntry.objects.filter(entry=he, dancer=dancer, partner=partner, couple=couple)
                if mismatches_in_database.count() == 0:
                    mismatch.save()
                # else:
                #     print("Mismatch exists")
            self.unmatched_heats += 1
